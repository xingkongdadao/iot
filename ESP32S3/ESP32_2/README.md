# ESP32_2 - 数据收集与上传程序

## 📋 项目简介

ESP32_2 是一个基于 ESP32 微控制器的数据收集与上传程序，专门设计用于传感器数据的智能上传和本地存储。该程序采用**智能上传策略**：
- **优先直接上传**：当本地没有待上传数据且网络正常时，新数据直接上传到服务器（不保存到本地），减少存储写入，提高实时性
- **自动降级存储**：当本地有待上传数据或网络不可用时，新数据保存到本地，确保数据不丢失
- **批量上传**：本地数据采用批量上传方式（每次50条），提高上传效率
- **严格 FIFO 顺序**：先保存的数据先上传，确保数据顺序

## ✨ 功能特性

### 核心功能

1. **周期性数据收集**
   - 每 5 秒自动收集一条传感器数据
   - 生成模拟距离值（40.0 ~ 80.0 cm）
   - 自动获取当前时间戳（含时区信息）

2. **智能数据上传策略**
   - **直接上传模式**：本地无待上传数据且网络正常时，新数据直接上传（不保存本地）
   - **本地存储模式**：本地有待上传数据或网络不可用时，新数据保存到本地
   - **自动降级**：直接上传失败时，自动保存到本地等待后续上传
   - 减少本地存储写入，提高实时性，同时保证数据可靠性

3. **批量数据上传（严格 FIFO 顺序）**
   - 只要有网络连接且本地有数据，持续批量上传
   - 不受 5 秒收集间隔限制（每 0.5 秒检查一次）
   - **批量上传**：每次上传 50 条数据，提高上传效率
   - **严格 FIFO 顺序**：先保存的数据先上传，确保数据顺序
   - **批量删除**：批量上传成功后批量删除，减少文件操作
   - 上传失败时保留数据，等待下次重试

4. **本地数据持久化**
   - 使用 LittleFS 文件系统存储数据
   - 支持离线数据缓存，网络恢复后自动上传
   - 内存不足时自动删除最旧的数据（FIFO）
   - 支持大量数据存储（默认约 52,400 条）

5. **自动数据管理**
   - 批量上传成功后自动批量删除已上传的数据
   - 内存不足时自动删除最旧的数据
   - 自动管理本地存储空间

### 其他特性

- ✅ 自动 WiFi 连接与重连
- ✅ NTP 时间同步（支持时区配置）
- ✅ 内存管理（自动清理旧数据）
- ✅ 错误处理与日志输出
- ✅ 支持 HTTP/HTTPS 协议

## 🔧 硬件要求

- ESP32 开发板（推荐 ESP32-S3，支持 PSRAM）
- USB 数据线（用于上传程序和串口监控）
- 稳定的 WiFi 网络环境

## 📦 软件依赖

### Arduino IDE 库依赖

在 Arduino IDE 中安装以下库：

1. **WiFi** - ESP32 内置库
2. **WiFiClient** - ESP32 内置库
3. **WiFiClientSecure** - ESP32 内置库
4. **HTTPClient** - ESP32 内置库
5. **time** - ESP32 内置库
6. **LittleFS** - ESP32 文件系统库
7. **ArduinoJson** - 第三方库（需手动安装）
   - 安装方法：Arduino IDE → 工具 → 管理库 → 搜索 "ArduinoJson" → 安装

### Arduino IDE 配置

1. 安装 ESP32 开发板支持包
2. 选择开发板：工具 → 开发板 → ESP32 Arduino → 选择你的 ESP32 型号
3. 配置分区方案（如需要）：工具 → Partition Scheme → 选择支持 LittleFS 的方案

## ⚙️ 配置说明

### WiFi 配置

在代码中修改以下参数：

```cpp
const char* ssid = "GOGOTRANS";           // WiFi 名称
const char* password = "18621260183";    // WiFi 密码
```

### API 配置

```cpp
// 本地测试地址
const char* apiBaseUrl = "http://192.168.100.193:8001/api";

// 生产环境地址（使用时取消注释，并注释掉本地地址）
// const char* apiBaseUrl = "https://manage.gogotrans.com/api";

const char* apiKey = "mcu_8312592b29fd4c68a0e01336cf26f438";
const char ultrasonicSensorId[] = "8ea58210-c649-11f0-afa3-da038af01e18";
```

### 时区配置

```cpp
const long gmtOffset_sec = 7 * 3600;  // 东七区（UTC+7）
const int daylightOffset_sec = 0;     // 夏令时偏移（中国不使用夏令时）
```

### 数据收集间隔

```cpp
const unsigned long collectInterval = 5000;  // 每 5 秒收集一条数据（毫秒）
```

### 上传配置

```cpp
const unsigned long uploadCheckInterval = 500;  // 每 0.5 秒检查一次是否有数据需要上传
const int BATCH_UPLOAD_SIZE = 50;               // 每次批量上传的数据条数（10-100条）
```

### 存储配置

```cpp
const size_t JSON_DOC_SIZE = 1048576;  // JSON 文档大小（1MB），可存储约 52,400 条数据
const size_t minFreeHeap = 20000;      // 最小可用堆内存阈值（字节）
```

**存储容量建议：**

| JSON_DOC_SIZE | 可存储数据条数 | 适用场景 |
|--------------|--------------|---------|
| 32 KB        | ~1,630 条    | 小容量（每分钟1条可存约1.1天）|
| 64 KB        | ~3,270 条    | 中等容量（每分钟1条可存约2.3天）|
| 128 KB       | ~6,550 条    | 常规场景（每分钟1条可存约4.5天）|
| 256 KB       | ~13,100 条   | 常规场景（每分钟1条可存约9.1天）|
| 512 KB       | ~26,200 条   | 大容量（每分钟1条可存约18.2天）|
| **1 MB**     | **~52,400 条** | **当前配置，超大容量（每分钟1条可存约36.4天）** |
| 2 MB         | ~104,800 条  | 极限配置（需测试稳定性）|

## 🚀 使用方法

### 1. 准备工作

1. 安装 Arduino IDE 和 ESP32 开发板支持包
2. 安装所需的库（见"软件依赖"部分）
3. 配置 WiFi 和 API 参数（见"配置说明"部分）

### 2. 上传程序

1. 用 USB 数据线连接 ESP32 开发板到电脑
2. 在 Arduino IDE 中选择正确的端口：工具 → 端口 → 选择你的 ESP32 端口
3. 点击"上传"按钮，等待编译和上传完成

### 3. 监控运行状态

1. 打开串口监视器：工具 → 串口监视器
2. 设置波特率：115200
3. 观察程序运行日志

### 4. 查看数据

- 串口监视器会实时显示数据收集和上传状态
- 每 20 条数据会输出一次统计信息

## 📊 工作流程

```
┌─────────────────┐
│   程序启动      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 初始化 LittleFS │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  连接 WiFi      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  同步 NTP 时间  │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────────┐
│         主循环 (loop)                │
│                                     │
│  ┌──────────────────────────────┐  │
│  │  每 0.5 秒检查批量上传        │  │
│  │  → 检查 WiFi 连接            │  │
│  │  → 检查本地数据              │  │
│  │  → 批量读取数据（最多50条）   │  │
│  │  → 批量上传数据              │  │
│  │  → 上传成功批量删除          │  │
│  └──────────────────────────────┘  │
│                                     │
│  ┌──────────────────────────────┐  │
│  │  每 5 秒收集一条数据          │  │
│  │  → 生成模拟距离值             │  │
│  │  → 获取时间戳                 │  │
│  │  → 检查本地是否有待上传数据   │  │
│  │     ├─ 无且网络正常           │  │
│  │     │  → 尝试直接上传         │  │
│  │     │     ├─ 成功：完成       │  │
│  │     │     └─ 失败：保存本地   │  │
│  │     └─ 有或网络不可用         │  │
│  │        → 保存到本地存储       │  │
│  └──────────────────────────────┘  │
│                                     │
│  ┌──────────────────────────────┐  │
│  │  WiFi 断开时自动重连         │  │
│  │  （每 10 秒尝试一次）         │  │
│  └──────────────────────────────┘  │
└─────────────────────────────────────┘
```

## 🔄 与 ESP32_1 的区别

| 特性 | ESP32_1 | ESP32_2 |
|-----|---------|---------|
| **数据存储策略** | 有网络时立即上传，无网络时保存 | 智能上传：本地无待上传数据时直接上传，否则保存本地 |
| **上传方式** | 单条上传 | 批量上传（每次50条） |
| **上传时机** | 收集数据时立即尝试上传 | 独立循环持续批量上传（不受收集间隔限制）|
| **数据删除** | 上传成功后删除 | 批量上传成功后批量删除 |
| **离线处理** | 网络断开时保存，恢复后批量上传 | 网络断开时继续保存，恢复后持续批量上传 |
| **存储写入** | 网络正常时较少写入 | 本地无待上传数据时几乎不写入 |
| **适用场景** | 实时性要求高，网络稳定 | 数据可靠性要求高，网络不稳定，需要减少存储写入 |

## 📝 数据格式

### 本地存储格式

数据以 JSON 格式存储在 `/sensor_data.json` 文件中：

```json
{
  "c": 100,  // 数据条数
  "a": [     // 数据数组
    [45.5, 1704067200],  // [距离(cm), Unix时间戳]
    [52.3, 1704067205],
    ...
  ]
}
```

### 上传数据格式

上传到服务器的 JSON 格式：

```json
{
  "currentDistance": 45.5,
  "dataUpdatedAt": "2024-01-01T12:00:00+07:00"
}
```

## 🐛 故障排除

### 问题 1: WiFi 连接失败

**症状：** 串口显示 "WiFi 连接失败"

**解决方案：**
- 检查 WiFi 名称和密码是否正确
- 确认 WiFi 信号强度足够
- 检查路由器是否允许新设备连接
- 尝试重启 ESP32

### 问题 2: 时间同步失败

**症状：** 串口显示 "时间同步失败" 或时间戳为 0

**解决方案：**
- 确认 WiFi 已连接
- 检查 NTP 服务器是否可访问
- 确认时区配置正确
- 等待更长时间（可能需要多次尝试）

### 问题 3: 数据上传失败

**症状：** 串口显示 "上传失败"

**解决方案：**
- 检查 API 地址是否正确
- 确认 API Key 有效
- 检查网络连接是否稳定
- 查看服务器端日志

### 问题 4: 内存不足

**症状：** 串口显示 "可用内存不足"

**解决方案：**
- 减少 `JSON_DOC_SIZE` 的值
- 降低 `minFreeHeap` 阈值（不推荐）
- 增加上传频率（减少 `uploadCheckInterval`）
- 使用支持 PSRAM 的 ESP32 型号

### 问题 5: LittleFS 初始化失败

**症状：** 串口显示 "LittleFS 初始化失败"

**解决方案：**
- 检查开发板是否支持 LittleFS
- 在 Arduino IDE 中选择支持 LittleFS 的分区方案
- 尝试重新格式化文件系统

## 📈 性能指标

- **数据收集频率：** 每 5 秒一条
- **上传检查频率：** 每 0.5 秒一次
- **批量上传大小：** 每次 50 条数据
- **WiFi 重连间隔：** 每 10 秒一次
- **默认存储容量：** 约 52,400 条数据（1MB）
- **单条数据大小：** 约 20 字节
- **内存阈值：** 20,000 字节
- **智能上传优势：** 本地无待上传数据时，减少约 80% 的存储写入操作

## 🔒 安全注意事项

1. **API Key 安全**
   - 不要将包含真实 API Key 的代码提交到公共仓库
   - 建议使用环境变量或配置文件管理敏感信息

2. **HTTPS 连接**
   - 生产环境建议使用 HTTPS
   - 当前代码中 `setInsecure()` 仅用于测试，生产环境应配置证书验证

3. **WiFi 密码**
   - 不要在代码中硬编码 WiFi 密码
   - 考虑使用 WiFiManager 等库实现动态配置

## 📄 许可证

本项目代码仅供学习和参考使用。

## 👤 作者

ESP32 IoT 项目

## 📅 更新日志

### v2.0.0 (2024-01-XX)
- **智能上传策略**：本地无待上传数据且网络正常时，新数据直接上传（不保存本地）
- **批量上传优化**：从单条上传改为批量上传（每次50条），提高上传效率
- **批量删除优化**：批量上传成功后批量删除，减少文件操作次数
- **自动降级机制**：直接上传失败时自动保存到本地，确保数据不丢失
- 减少本地存储写入，提高实时性，同时保证数据可靠性

### v1.0.0 (2024-01-01)
- 初始版本发布
- 实现数据收集与本地存储功能
- 实现持续上传功能（单条上传）
- 支持 NTP 时间同步
- 支持自动 WiFi 重连

---

**提示：** 如有问题或建议，请查看串口监视器的详细日志信息。

